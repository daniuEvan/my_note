> - Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。
> - channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信

## channel 数据结构

- `src/runtime/chan.go:hchan`

  ```go
  type hchan struct {
      qcount   uint           // 当前队列中剩余元素个数
      dataqsiz uint           // 环形队列长度，即可以存放的元素个数
      buf      unsafe.Pointer // 环形队列指针
      elemsize uint16         // 每个元素的大小
      closed   uint32         // 标识关闭状态   ** 关闭状态的channel并不是nil
      elemtype *_type         // 元素类型
      sendx    uint           // 队列下标，指示元素写入时存放到队列中的位置
      recvx    uint           // 队列下标，指示元素从队列的该位置读出
      recvq    waitq          // 等待读消息的goroutine队列
      sendq    waitq          // 等待写消息的goroutine队列
      lock mutex              // 互斥锁，chan不允许并发读写
  }
  ```

  ***关闭状态的channel并不是nil***

### 1. 环形队列

- 优点
  1. 避免假溢出现象（由于入队和出队的操作，头尾指针只增加不减少，致使被删元素的空间永远无法重新利用，当队列继续存储元素时，出现尾指针已经到达了队列尾，而实际头指针前面并未满的情况），可以将队列空间充分重复利用
  2. 首尾相连的FIFO的数据结构，采用数据的线性空间，数据组织简单，能快速知道队列是否满/空
  3. 广泛用于网络数据收发，和不同程序间数据交换，均使用了环形队列
- 实现原理
  - 内存上并没有环形的结构，因此环形队列实际上是数组的线性空间来实现的。
  - 当数据到了尾部该如何处理呢？它将转回到原来位置进行处理，通过**取模**操作来实现
- 环形队列的几个判断条件
  - front:指向队列的第一个元素，初始值front=0
  - rear: 指向队列的**最后一个元素的后一个位置**（预留一个空间作为约定）,初始值rear=0
  - maxSize: 数组的最大容量
  - 队空：front == rear
  - **队满：**(rear+1)%maxSize == front
  - 队列中的有效数据个数：(rear+maxSize-front)% maxSize
  ![image-20220614115250394](https://raw.githubusercontent.com/daniuEvan/pictrues/main/Typora/image-20220614115250394.png)



- chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。

  ![image-20220614113949803](https://raw.githubusercontent.com/daniuEvan/pictrues/main/Typora/image-20220614113949803.png)

  1. `qcount` 表示队列中还有两个元素;
  2. `dataqsiz` 表示队列大小,队列长度为6，即可缓存6个元素；
  3. `buf` : 队列指针, 执行队列内存 
  4. `sendx`: 后续写入的数据存储的位置，取值[0, 6)
  5. `recvx`: 从该位置读取数据, 取值[0, 6)；

### 2. 其他

- 从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞
- 向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞
- 被阻塞的goroutine将会挂在channel的等待队列中
  - 因读阻塞的goroutine会被向channel写入数据的goroutine唤醒
  - 因写阻塞的goroutine会被从channel读数据的goroutine唤醒

- elemtype代表类型，用于数据传递过程中的赋值
- elemsize代表类型大小，用于在buf中定位元素位置.

- 一个channel同时仅允许被一个goroutine读写，为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。

## channel 创建

- 创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定。

  ```go
  func makechan(t *chantype, size int) *hchan {
      var c *hchan
      c = new(hchan)
      c.buf = malloc(元素类型大小*size)
      c.elemsize = 元素类型大小
      c.elemtype = 元素类型
      c.dataqsiz = size
  
      return c
  }
  ```

  

